// Generable.swift
// Conduit
//
// Created for Conduit structured output generation.

import Foundation

// MARK: - Generable Protocol

/// A type that can be generated by language models with type safety.
///
/// `Generable` is the foundation protocol for Conduit's structured output system,
/// modeled after Apple's FoundationModels in iOS 26. Types conforming to this
/// protocol can be used as the return type for language model generation,
/// enabling type-safe structured outputs.
///
/// ## Overview
///
/// The `Generable` protocol defines three key requirements:
///
/// 1. **Schema**: A static description of the type's structure for LLM guidance
/// 2. **Partial Type**: An associated type for streaming responses where fields are optional
/// 3. **Content Conversion**: Methods to convert to/from `StructuredContent`
///
/// ## Usage with @Generable Macro
///
/// The most common way to conform to `Generable` is using the `@Generable` macro:
///
/// ```swift
/// @Generable
/// struct WeatherReport {
///     @Guide(description: "Temperature in Celsius")
///     let temperature: Int
///
///     @Guide(description: "Current conditions", .anyOf(["sunny", "cloudy", "rainy"]))
///     let conditions: String
///
///     @Guide(description: "Chance of precipitation", .range(0...100))
///     let precipitationChance: Int
/// }
///
/// // Generate structured output from an LLM
/// let report = try await llm.generate(
///     prompt: "What's the weather in Paris?",
///     returning: WeatherReport.self
/// )
/// print("Temperature: \(report.temperature)C, Conditions: \(report.conditions)")
/// ```
///
/// ## Manual Conformance
///
/// For advanced use cases, you can manually conform to `Generable`:
///
/// ```swift
/// struct SimpleMessage: Generable {
///     let text: String
///
///     static var schema: Schema {
///         .object(
///             name: "SimpleMessage",
///             description: "A simple message",
///             properties: [
///                 "text": Schema.Property(
///                     schema: .string(constraints: []),
///                     description: "The message text"
///                 )
///             ]
///         )
///     }
///
///     typealias Partial = SimpleMessage
///
///     var generableContent: StructuredContent {
///         .object(["text": .string(text)])
///     }
///
///     init(from structuredContent: StructuredContent) throws {
///         let obj = try structuredContent.object
///         guard let textContent = obj["text"] else {
///             throw StructuredContentError.missingKey("text")
///         }
///         self.text = try textContent.string
///     }
///
///     init(text: String) {
///         self.text = text
///     }
/// }
/// ```
///
/// ## Built-in Conformances
///
/// The following types conform to `Generable` out of the box:
///
/// - `String`: For simple text generation
/// - `Int`: For integer values
/// - `Double`: For floating-point numbers
/// - `Bool`: For boolean values
/// - `Optional<T>` where `T: Generable`: For optional values
/// - `Array<T>` where `T: Generable`: For collections
///
/// ## Streaming with Partial Types
///
/// The `Partial` associated type enables streaming responses where fields arrive
/// incrementally:
///
/// ```swift
/// for try await partial in llm.stream(returning: WeatherReport.self) {
///     // Partial may have only some fields populated
///     if let temp = partial.temperature {
///         print("Temperature so far: \(temp)")
///     }
/// }
/// ```
///
/// ## Thread Safety
///
/// The `Generable` protocol requires `Sendable` conformance, ensuring types
/// can be safely passed across actor boundaries in Swift 6.2's strict concurrency.
///
/// - SeeAlso: `GenerableContentConvertible`, `Schema`, `StructuredContent`
public protocol Generable: GenerableContentConvertible, Sendable {

    /// The partial type used for streaming responses.
    ///
    /// During streaming generation, the language model may produce incomplete
    /// results. The `Partial` type represents these intermediate states where
    /// some fields may not yet be available.
    ///
    /// For simple types (String, Int, etc.), `Partial` is typically `Self`.
    /// For complex types, `Partial` usually has all properties as optionals.
    ///
    /// ## Example
    ///
    /// For a `Person` struct, the partial might be:
    ///
    /// ```swift
    /// struct Person: Generable {
    ///     let name: String
    ///     let age: Int
    ///
    ///     struct PartialPerson: GenerableContentConvertible, Sendable {
    ///         var name: String?
    ///         var age: Int?
    ///     }
    ///
    ///     typealias Partial = PartialPerson
    /// }
    /// ```
    associatedtype Partial: GenerableContentConvertible, Sendable

    /// The schema describing the structure and constraints of this type.
    ///
    /// The schema is used by language models to understand what structure
    /// the generated output should have. It includes type information,
    /// property names, descriptions, and validation constraints.
    ///
    /// ## Example
    ///
    /// ```swift
    /// static var schema: Schema {
    ///     .object(
    ///         name: "Person",
    ///         description: "A person with name and age",
    ///         properties: [
    ///             "name": Schema.Property(
    ///                 schema: .string(constraints: []),
    ///                 description: "The person's name"
    ///             ),
    ///             "age": Schema.Property(
    ///                 schema: .integer(constraints: [.range(lowerBound: 0, upperBound: 150)]),
    ///                 description: "The person's age in years"
    ///             )
    ///         ]
    ///     )
    /// }
    /// ```
    static var schema: Schema { get }
}

// MARK: - GenerableContentConvertible Protocol

/// A type that can be converted to and from `StructuredContent`.
///
/// `GenerableContentConvertible` provides the bidirectional conversion between
/// Swift types and the intermediate `StructuredContent` representation used
/// by language models.
///
/// ## Overview
///
/// This protocol is separate from `Generable` to allow types like partial
/// structs (used in streaming) to participate in content conversion without
/// requiring a full schema.
///
/// ## Usage
///
/// Types conforming to this protocol must implement:
///
/// 1. `generableContent`: Converts the instance to structured content
/// 2. `init(from:)`: Creates an instance from structured content
///
/// ## Example
///
/// ```swift
/// struct Point: GenerableContentConvertible, Sendable {
///     let x: Double
///     let y: Double
///
///     var generableContent: StructuredContent {
///         .object([
///             "x": .number(x),
///             "y": .number(y)
///         ])
///     }
///
///     init(from structuredContent: StructuredContent) throws {
///         let obj = try structuredContent.object
///         guard let xContent = obj["x"], let yContent = obj["y"] else {
///             throw StructuredContentError.missingKey("x or y")
///         }
///         self.x = try xContent.double
///         self.y = try yContent.double
///     }
///
///     init(x: Double, y: Double) {
///         self.x = x
///         self.y = y
///     }
/// }
/// ```
///
/// - SeeAlso: `Generable`, `StructuredContent`
public protocol GenerableContentConvertible {

    /// The structured representation of this instance.
    ///
    /// Converts the instance to a `StructuredContent` value that can be
    /// serialized to JSON for language model consumption.
    ///
    /// ## Example
    ///
    /// ```swift
    /// let person = Person(name: "Alice", age: 30)
    /// let content = person.generableContent
    /// // StructuredContent.object(["name": .string("Alice"), "age": .number(30)])
    /// ```
    var generableContent: StructuredContent { get }

    /// Creates an instance from structured content.
    ///
    /// Parses the structured content and constructs an instance of this type.
    ///
    /// ## Example
    ///
    /// ```swift
    /// let content = StructuredContent.object([
    ///     "name": .string("Alice"),
    ///     "age": .number(30)
    /// ])
    /// let person = try Person(from: content)
    /// ```
    ///
    /// - Parameter structuredContent: The structured content to parse
    /// - Throws: `StructuredContentError` if the content cannot be converted
    init(from structuredContent: StructuredContent) throws
}

// MARK: - String Conformance

/// `String` conforms to `Generable` for simple text generation use cases.
///
/// ## Usage
///
/// ```swift
/// // Generate a simple string response
/// let response: String = try await llm.generate(
///     prompt: "What is the capital of France?",
///     returning: String.self
/// )
/// print(response) // "Paris"
/// ```
extension String: Generable {

    /// The partial type for streaming is the same as `String`.
    public typealias Partial = String

    /// The schema for a string type.
    public static var schema: Schema {
        .string(constraints: [])
    }

    /// Converts this string to structured content.
    public var generableContent: StructuredContent {
        StructuredContent(kind: .string(self))
    }

    /// Creates a string from structured content.
    ///
    /// - Parameter structuredContent: The structured content containing a string
    /// - Throws: `StructuredContentError.typeMismatch` if not a string
    public init(from structuredContent: StructuredContent) throws {
        self = try structuredContent.string
    }
}

// MARK: - Int Conformance

/// `Int` conforms to `Generable` for integer generation use cases.
///
/// ## Usage
///
/// ```swift
/// // Generate an integer response
/// let count: Int = try await llm.generate(
///     prompt: "How many planets are in our solar system?",
///     returning: Int.self
/// )
/// print(count) // 8
/// ```
extension Int: Generable {

    /// The partial type for streaming is the same as `Int`.
    public typealias Partial = Int

    /// The schema for an integer type.
    public static var schema: Schema {
        .integer(constraints: [])
    }

    /// Converts this integer to structured content.
    public var generableContent: StructuredContent {
        StructuredContent(kind: .number(Double(self)))
    }

    /// Creates an integer from structured content.
    ///
    /// - Parameter structuredContent: The structured content containing a number
    /// - Throws: `StructuredContentError.typeMismatch` if not a number
    /// - Throws: `StructuredContentError.invalidIntegerValue` if the number has a fractional part
    public init(from structuredContent: StructuredContent) throws {
        self = try structuredContent.int
    }
}

// MARK: - Double Conformance

/// `Double` conforms to `Generable` for floating-point number generation use cases.
///
/// ## Usage
///
/// ```swift
/// // Generate a floating-point response
/// let temperature: Double = try await llm.generate(
///     prompt: "What is the boiling point of water in Celsius?",
///     returning: Double.self
/// )
/// print(temperature) // 100.0
/// ```
extension Double: Generable {

    /// The partial type for streaming is the same as `Double`.
    public typealias Partial = Double

    /// The schema for a floating-point number type.
    public static var schema: Schema {
        .number(constraints: [])
    }

    /// Converts this double to structured content.
    public var generableContent: StructuredContent {
        StructuredContent(kind: .number(self))
    }

    /// Creates a double from structured content.
    ///
    /// - Parameter structuredContent: The structured content containing a number
    /// - Throws: `StructuredContentError.typeMismatch` if not a number
    public init(from structuredContent: StructuredContent) throws {
        self = try structuredContent.double
    }
}

// MARK: - Bool Conformance

/// `Bool` conforms to `Generable` for boolean generation use cases.
///
/// ## Usage
///
/// ```swift
/// // Generate a boolean response
/// let isEven: Bool = try await llm.generate(
///     prompt: "Is 42 an even number?",
///     returning: Bool.self
/// )
/// print(isEven) // true
/// ```
extension Bool: Generable {

    /// The partial type for streaming is the same as `Bool`.
    public typealias Partial = Bool

    /// The schema for a boolean type.
    public static var schema: Schema {
        .boolean(constraints: [])
    }

    /// Converts this boolean to structured content.
    public var generableContent: StructuredContent {
        StructuredContent(kind: .bool(self))
    }

    /// Creates a boolean from structured content.
    ///
    /// - Parameter structuredContent: The structured content containing a boolean
    /// - Throws: `StructuredContentError.typeMismatch` if not a boolean
    public init(from structuredContent: StructuredContent) throws {
        self = try structuredContent.bool
    }
}

// MARK: - Optional GenerableContentConvertible Conformance

/// `Optional` conforms to `GenerableContentConvertible` when its wrapped value does.
///
/// This enables optional properties in `Generable` types.
extension Optional: GenerableContentConvertible where Wrapped: GenerableContentConvertible {

    /// Converts this optional to structured content.
    ///
    /// - Returns: `.null` if `nil`, otherwise the wrapped value's content
    public var generableContent: StructuredContent {
        switch self {
        case .none:
            return StructuredContent(kind: .null)
        case .some(let value):
            return value.generableContent
        }
    }

    /// Creates an optional from structured content.
    ///
    /// - Parameter structuredContent: The structured content
    /// - Returns: `nil` if the content is null, otherwise the wrapped value
    /// - Throws: If the wrapped type's initialization fails
    public init(from structuredContent: StructuredContent) throws {
        if structuredContent.isNull {
            self = .none
        } else {
            self = .some(try Wrapped(from: structuredContent))
        }
    }
}

// MARK: - Optional Generable Conformance

/// `Optional` conforms to `Generable` when its wrapped value conforms to `Generable`.
///
/// ## Usage
///
/// ```swift
/// @Generable
/// struct Person {
///     let name: String
///     let nickname: String?  // Optional property
/// }
/// ```
extension Optional: Generable where Wrapped: Generable {

    /// The partial type is an optional of the wrapped type's partial.
    public typealias Partial = Wrapped.Partial?

    /// The schema wraps the wrapped type's schema in `.optional`.
    public static var schema: Schema {
        .optional(wrapped: Wrapped.schema)
    }
}

// MARK: - Array GenerableContentConvertible Conformance

/// `Array` conforms to `GenerableContentConvertible` when its elements do.
///
/// This enables array properties in `Generable` types.
extension Array: GenerableContentConvertible where Element: GenerableContentConvertible {

    /// Converts this array to structured content.
    ///
    /// Each element is converted to its structured content representation.
    public var generableContent: StructuredContent {
        StructuredContent(kind: .array(self.map { $0.generableContent }))
    }

    /// Creates an array from structured content.
    ///
    /// - Parameter structuredContent: The structured content containing an array
    /// - Throws: `StructuredContentError.typeMismatch` if not an array
    /// - Throws: If any element's initialization fails
    public init(from structuredContent: StructuredContent) throws {
        let array = try structuredContent.array
        self = try array.map { try Element(from: $0) }
    }
}

// MARK: - Array Generable Conformance

/// `Array` conforms to `Generable` when its elements conform to `Generable`.
///
/// ## Usage
///
/// ```swift
/// // Generate an array response
/// let ingredients: [String] = try await llm.generate(
///     prompt: "List the main ingredients for a margherita pizza",
///     returning: [String].self
/// )
/// print(ingredients) // ["tomatoes", "mozzarella", "basil", "olive oil"]
///
/// @Generable
/// struct Recipe {
///     let name: String
///     let ingredients: [String]  // Array of strings
///     let steps: [String]        // Another array
/// }
/// ```
extension Array: Generable where Element: Generable {

    /// The partial type is an array of element partials.
    public typealias Partial = [Element.Partial]

    /// The schema is an array with the element's schema as items.
    public static var schema: Schema {
        .array(items: Element.schema, constraints: [])
    }
}
