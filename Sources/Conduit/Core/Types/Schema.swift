// Schema.swift
// Conduit
//
// Created for Conduit structured output generation.

import Foundation
import OrderedCollections

// MARK: - Schema

/// Defines the structure and constraints of types that can be generated by language models.
///
/// A `Schema` describes the expected format of data for language model generation,
/// including type information, validation constraints, and metadata to guide generation.
/// This is the foundational type for Conduit's structured output system, modeled after
/// Apple's FoundationModels in iOS 26.
///
/// ## Overview
///
/// Schemas represent the shape and constraints of data types. They are used by the
/// `@Generable` macro system to describe how language models should generate responses
/// that conform to specific Swift types.
///
/// ## Supported Types
///
/// - **Primitive Types**: `string`, `integer`, `number` (Double), `boolean`
/// - **Collection Types**: `array` with item schema
/// - **Composite Types**: `object` with named properties
/// - **Union Types**: `anyOf` for polymorphic schemas
/// - **Optional Types**: `optional` wrapper for nullable values
///
/// ## Usage
///
/// Schemas are typically generated automatically by the `@Generable` macro:
///
/// ```swift
/// @Generable
/// struct Person {
///     let name: String
///     let age: Int
/// }
///
/// // The macro generates:
/// // static var schema: Schema {
/// //     .object(
/// //         name: "Person",
/// //         description: nil,
/// //         properties: [
/// //             "name": Property(schema: .string(constraints: []), description: nil),
/// //             "age": Property(schema: .integer(constraints: []), description: nil)
/// //         ]
/// //     )
/// // }
/// ```
///
/// You can also build schemas manually for advanced use cases:
///
/// ```swift
/// let schema = Schema.object(
///     name: "WeatherReport",
///     description: "Current weather conditions",
///     properties: [
///         "temperature": Property(
///             schema: .integer(constraints: []).withConstraint(.range(-50...50)),
///             description: "Temperature in Celsius"
///         ),
///         "conditions": Property(
///             schema: .string(constraints: []).withConstraint(.anyOf(["sunny", "cloudy", "rainy"])),
///             description: "Current weather conditions"
///         )
///     ]
/// )
/// ```
///
/// ## Thread Safety
///
/// `Schema` is `Sendable` and safe to use across actor boundaries.
///
/// - SeeAlso: `Generable`, `GenerableContentConvertible`, `Constraint`
public enum Schema: Sendable, Equatable {

    // MARK: - Cases

    /// A value that may possibly be null or absent.
    ///
    /// Wraps another schema to indicate the value is optional.
    /// Used for Swift `Optional` types.
    ///
    /// ```swift
    /// let optionalString = Schema.optional(wrapped: .string(constraints: []))
    /// ```
    indirect case optional(wrapped: Schema)

    /// An object with defined properties.
    ///
    /// Represents a composite type with named fields, similar to a Swift struct or class.
    ///
    /// - Parameters:
    ///   - name: The type name for this object
    ///   - description: Optional description for language model guidance
    ///   - properties: Ordered dictionary of property names to their schemas
    ///
    /// ```swift
    /// let personSchema = Schema.object(
    ///     name: "Person",
    ///     description: "A person with name and age",
    ///     properties: [
    ///         "name": Property(schema: .string(constraints: []), description: nil),
    ///         "age": Property(schema: .integer(constraints: []), description: nil)
    ///     ]
    /// )
    /// ```
    case object(name: String, description: String?, properties: OrderedDictionary<String, Property>)

    /// A union type that can match any of the provided schemas.
    ///
    /// Used for Swift enums with associated values or protocol types.
    ///
    /// - Parameters:
    ///   - name: The type name for this union
    ///   - description: Optional description for language model guidance
    ///   - schemas: Array of possible schemas this union can match
    ///
    /// ```swift
    /// let mediaSchema = Schema.anyOf(
    ///     name: "Media",
    ///     description: "Either an image or video",
    ///     schemas: [imageSchema, videoSchema]
    /// )
    /// ```
    indirect case anyOf(name: String, description: String?, schemas: [Schema])

    /// An array containing items of a specific schema.
    ///
    /// - Parameters:
    ///   - items: The schema for array elements
    ///   - constraints: Array-level constraints (count limits, etc.)
    ///
    /// ```swift
    /// let numbersSchema = Schema.array(
    ///     items: .integer(constraints: []),
    ///     constraints: [.count(lowerBound: 1, upperBound: 10)]
    /// )
    /// ```
    indirect case array(items: Schema, constraints: [ArrayConstraint])

    /// A string value with optional constraints.
    ///
    /// - Parameter constraints: String-level constraints (pattern, constant, anyOf)
    ///
    /// ```swift
    /// let emailSchema = Schema.string(constraints: [.pattern("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$")])
    /// ```
    case string(constraints: [StringConstraint])

    /// An integer value with optional constraints.
    ///
    /// - Parameter constraints: Integer-level constraints (range limits)
    ///
    /// ```swift
    /// let ageSchema = Schema.integer(constraints: [.range(lowerBound: 0, upperBound: 150)])
    /// ```
    case integer(constraints: [IntConstraint])

    /// A floating-point number with optional constraints.
    ///
    /// - Parameter constraints: Number-level constraints (range limits)
    ///
    /// ```swift
    /// let priceSchema = Schema.number(constraints: [.range(lowerBound: 0.0, upperBound: nil)])
    /// ```
    case number(constraints: [DoubleConstraint])

    /// A boolean value with optional constraints.
    ///
    /// - Parameter constraints: Boolean-level constraints (currently unused)
    ///
    /// ```swift
    /// let flagSchema = Schema.boolean(constraints: [])
    /// ```
    case boolean(constraints: [BoolConstraint])

    // MARK: - Constraint Application

    /// Returns a new schema with the given constraint applied.
    ///
    /// The method attempts to apply the constraint to the schema. If the constraint
    /// is not compatible with the schema structure, it is a no-op.
    ///
    /// ## Usage
    ///
    /// ```swift
    /// let constrainedAge = Schema.integer(constraints: [])
    ///     .withConstraint(.range(0...150))
    ///
    /// let constrainedName = Schema.string(constraints: [])
    ///     .withConstraint(.pattern("^[A-Z][a-z]+$"))
    /// ```
    ///
    /// - Parameter constraint: The typed constraint to add
    /// - Returns: A new schema with the constraint applied
    public func withConstraint<Value>(_ constraint: Constraint<Value>) -> Schema {
        withConstraint(AnyConstraint(constraint))
    }

    /// Returns a new schema with the given constraints applied.
    ///
    /// The method attempts to apply each constraint to the schema. Incompatible
    /// constraints are silently ignored.
    ///
    /// - Parameter constraints: The typed constraints to add
    /// - Returns: A new schema with the constraints applied
    public func withConstraints<Value>(_ constraints: [Constraint<Value>]) -> Schema {
        withConstraints(constraints.map(AnyConstraint.init))
    }

    /// Internal constraint application with type-erased constraints.
    func withConstraint(_ constraint: AnyConstraint) -> Schema {
        // For optional schemas, apply the constraint to the wrapped schema
        if case .optional(let wrapped) = self {
            return .optional(wrapped: wrapped.withConstraint(constraint))
        }

        switch (self, constraint.payload) {
        // Handle sub-constraints for arrays
        case (.array(let items, let constraints), .sub(let subConstraint)):
            return .array(items: items.withConstraint(subConstraint), constraints: constraints)

        // Handle direct constraints
        case (_, .this(let kind)):
            switch (self, kind) {
            case (.string(let constraints), .string(let newConstraint)):
                return .string(constraints: constraints + [newConstraint])

            case (.integer(let constraints), .int(let newConstraint)):
                return .integer(constraints: constraints + [newConstraint])

            case (.number(let constraints), .double(let newConstraint)):
                return .number(constraints: constraints + [newConstraint])

            case (.boolean(let constraints), .boolean):
                return .boolean(constraints: constraints)

            case (.array(let items, let constraints), .array(let arrayConstraint)):
                return .array(items: items, constraints: constraints + [arrayConstraint])

            default:
                // Incompatible constraint type - return unchanged
                assertionFailure("Invalid constraint \(kind) for schema \(self)")
                return self
            }

        default:
            assertionFailure("Invalid constraint \(constraint.payload) for schema \(self)")
            return self
        }
    }

    /// Internal batch constraint application.
    func withConstraints(_ constraints: [AnyConstraint]) -> Schema {
        constraints.reduce(self) { schema, constraint in
            schema.withConstraint(constraint)
        }
    }

    // MARK: - Property

    /// Represents a sub-schema of an object member.
    ///
    /// A `Property` defines a named field within an object schema, including
    /// its type (via schema) and optional description for language model guidance.
    ///
    /// ## Usage
    ///
    /// ```swift
    /// let nameProperty = Schema.Property(
    ///     schema: .string(constraints: []),
    ///     description: "The person's full name",
    ///     isRequired: true
    /// )
    /// ```
    ///
    /// Optional properties should wrap their schema in `.optional(wrapped:)`:
    ///
    /// ```swift
    /// let nicknameProperty = Schema.Property(
    ///     schema: .optional(wrapped: .string(constraints: [])),
    ///     description: "An optional nickname",
    ///     isRequired: false
    /// )
    /// ```
    public struct Property: Sendable, Equatable {

        /// The schema that defines this property's structure.
        public let schema: Schema

        /// Provides context for this property within the parent object.
        ///
        /// This description is used by language models to understand
        /// what values are appropriate for this property.
        public let description: String?

        /// Whether this property is required in the object.
        ///
        /// Required properties must always be present in the generated output.
        /// Optional properties may be omitted.
        public let isRequired: Bool

        /// Creates a new property with the specified schema and metadata.
        ///
        /// - Parameters:
        ///   - schema: The schema that defines this property's structure
        ///   - description: Optional description for language model guidance
        ///   - isRequired: Whether this property must be present (defaults to true)
        public init(schema: Schema, description: String?, isRequired: Bool = true) {
            self.schema = schema
            self.description = description
            self.isRequired = isRequired
        }
    }
}

// MARK: - Schema Utilities

extension Schema {

    /// Returns `true` when the schema is wrapped in `.optional`.
    ///
    /// ```swift
    /// let optionalString = Schema.optional(wrapped: .string(constraints: []))
    /// optionalString.isOptional // true
    ///
    /// let requiredString = Schema.string(constraints: [])
    /// requiredString.isOptional // false
    /// ```
    public var isOptional: Bool {
        if case .optional = self {
            return true
        }
        return false
    }

    /// Returns the innermost schema by stripping all `.optional` wrappers.
    ///
    /// ```swift
    /// let deeplyOptional = Schema.optional(wrapped: .optional(wrapped: .string(constraints: [])))
    /// deeplyOptional.unwrapped // .string(constraints: [])
    /// ```
    public var unwrapped: Schema {
        if case .optional(let wrapped) = self {
            return wrapped.unwrapped
        }
        return self
    }

    /// The type name for this schema (for objects and anyOf types).
    ///
    /// Returns `nil` for primitive types without explicit names.
    public var typeName: String? {
        switch self {
        case .object(let name, _, _):
            return name
        case .anyOf(let name, _, _):
            return name
        case .optional(let wrapped):
            return wrapped.typeName
        default:
            return nil
        }
    }
}

// MARK: - Schema Codable

extension Schema: Codable {

    private enum CodingKeys: String, CodingKey {
        case type
        case constraints
        case items
        case name
        case description
        case properties
        case wrapped
        case schemas
    }

    private enum SchemaType: String, Codable {
        case string
        case integer
        case number
        case boolean
        case array
        case object
        case optional
        case anyOf
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let type = try container.decode(SchemaType.self, forKey: .type)

        switch type {
        case .string:
            let constraints = try container.decodeIfPresent([StringConstraint].self, forKey: .constraints) ?? []
            self = .string(constraints: constraints)

        case .integer:
            let constraints = try container.decodeIfPresent([IntConstraint].self, forKey: .constraints) ?? []
            self = .integer(constraints: constraints)

        case .number:
            let constraints = try container.decodeIfPresent([DoubleConstraint].self, forKey: .constraints) ?? []
            self = .number(constraints: constraints)

        case .boolean:
            let constraints = try container.decodeIfPresent([BoolConstraint].self, forKey: .constraints) ?? []
            self = .boolean(constraints: constraints)

        case .array:
            let items = try container.decode(Schema.self, forKey: .items)
            let constraints = try container.decodeIfPresent([ArrayConstraint].self, forKey: .constraints) ?? []
            self = .array(items: items, constraints: constraints)

        case .object:
            let name = try container.decode(String.self, forKey: .name)
            let description = try container.decodeIfPresent(String.self, forKey: .description)
            let properties = try container.decode(OrderedDictionary<String, Property>.self, forKey: .properties)
            self = .object(name: name, description: description, properties: properties)

        case .optional:
            let wrapped = try container.decode(Schema.self, forKey: .wrapped)
            self = .optional(wrapped: wrapped)

        case .anyOf:
            let name = try container.decode(String.self, forKey: .name)
            let description = try container.decodeIfPresent(String.self, forKey: .description)
            let schemas = try container.decode([Schema].self, forKey: .schemas)
            self = .anyOf(name: name, description: description, schemas: schemas)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        switch self {
        case .string(let constraints):
            try container.encode(SchemaType.string, forKey: .type)
            if !constraints.isEmpty {
                try container.encode(constraints, forKey: .constraints)
            }

        case .integer(let constraints):
            try container.encode(SchemaType.integer, forKey: .type)
            if !constraints.isEmpty {
                try container.encode(constraints, forKey: .constraints)
            }

        case .number(let constraints):
            try container.encode(SchemaType.number, forKey: .type)
            if !constraints.isEmpty {
                try container.encode(constraints, forKey: .constraints)
            }

        case .boolean(let constraints):
            try container.encode(SchemaType.boolean, forKey: .type)
            if !constraints.isEmpty {
                try container.encode(constraints, forKey: .constraints)
            }

        case .array(let items, let constraints):
            try container.encode(SchemaType.array, forKey: .type)
            try container.encode(items, forKey: .items)
            if !constraints.isEmpty {
                try container.encode(constraints, forKey: .constraints)
            }

        case .object(let name, let description, let properties):
            try container.encode(SchemaType.object, forKey: .type)
            try container.encode(name, forKey: .name)
            try container.encodeIfPresent(description, forKey: .description)
            try container.encode(properties, forKey: .properties)

        case .optional(let wrapped):
            try container.encode(SchemaType.optional, forKey: .type)
            try container.encode(wrapped, forKey: .wrapped)

        case .anyOf(let name, let description, let schemas):
            try container.encode(SchemaType.anyOf, forKey: .type)
            try container.encode(name, forKey: .name)
            try container.encodeIfPresent(description, forKey: .description)
            try container.encode(schemas, forKey: .schemas)
        }
    }
}

// MARK: - Property Codable

extension Schema.Property: Codable {

    private enum CodingKeys: String, CodingKey {
        case schema
        case description
        case isRequired
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        schema = try container.decode(Schema.self, forKey: .schema)
        description = try container.decodeIfPresent(String.self, forKey: .description)
        isRequired = try container.decodeIfPresent(Bool.self, forKey: .isRequired) ?? true
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(schema, forKey: .schema)
        try container.encodeIfPresent(description, forKey: .description)
        try container.encode(isRequired, forKey: .isRequired)
    }
}

// MARK: - Schema Hashable

extension Schema: Hashable {
    public func hash(into hasher: inout Hasher) {
        switch self {
        case .string(let constraints):
            hasher.combine("string")
            hasher.combine(constraints)

        case .integer(let constraints):
            hasher.combine("integer")
            hasher.combine(constraints)

        case .number(let constraints):
            hasher.combine("number")
            hasher.combine(constraints)

        case .boolean(let constraints):
            hasher.combine("boolean")
            hasher.combine(constraints)

        case .array(let items, let constraints):
            hasher.combine("array")
            hasher.combine(items)
            hasher.combine(constraints)

        case .object(let name, let description, let properties):
            hasher.combine("object")
            hasher.combine(name)
            hasher.combine(description)
            hasher.combine(properties)

        case .optional(let wrapped):
            hasher.combine("optional")
            hasher.combine(wrapped)

        case .anyOf(let name, let description, let schemas):
            hasher.combine("anyOf")
            hasher.combine(name)
            hasher.combine(description)
            hasher.combine(schemas)
        }
    }
}

// MARK: - Property Hashable

extension Schema.Property: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(schema)
        hasher.combine(description)
        hasher.combine(isRequired)
    }
}

// MARK: - Schema CustomStringConvertible

extension Schema: CustomStringConvertible {
    public var description: String {
        switch self {
        case .string:
            return "String"
        case .integer:
            return "Int"
        case .number:
            return "Double"
        case .boolean:
            return "Bool"
        case .array(let items, _):
            return "[\(items.description)]"
        case .object(let name, _, _):
            return name
        case .optional(let wrapped):
            return "\(wrapped.description)?"
        case .anyOf(let name, _, _):
            return name
        }
    }
}
